# Реализация мультиплеера и игры с компьютером

## Общая архитектура

Оба режима используют единую функцию `open_game_window(mode)`, где параметр `mode` определяет поведение:
- `mode="friend"` - мультиплеер (два игрока)
- `mode="computer"` - игра против компьютера

---

## 1. Реализация мультиплеера (режим "С другом")

### 1.1 Инициализация

```python
if mode == "friend":
    snake1 = Snake((5, rows // 2), (1, 0), "#FF6B9D")
    snake2 = Snake((cols - 6, rows // 2), (-1, 0), "#4ECDC4")
    snakes = [snake1, snake2]
```

**Особенности:**
- Создаются две змейки с разными стартовыми позициями
- `snake1`: позиция (5, rows//2), движется вправо (1, 0), розовый цвет
- `snake2`: позиция (cols-6, rows//2), движется влево (-1, 0), бирюзовый цвет
- Обе змейки добавляются в список `snakes` для единой обработки

### 1.2 Управление клавиатурой

```python
def on_key_press(event):
    key = event.keysym.lower()
    
    # Управление для первой змейки (WASD)
    if key == 'w' and snake1.direction != (0, 1):
        snake1.next_direction = (0, -1)  # Вверх
    elif key == 's' and snake1.direction != (0, -1):
        snake1.next_direction = (0, 1)   # Вниз
    elif key == 'a' and snake1.direction != (1, 0):
        snake1.next_direction = (-1, 0)  # Влево
    elif key == 'd' and snake1.direction != (-1, 0):
        snake1.next_direction = (1, 0)   # Вправо
    
    # Управление для второй змейки (стрелки)
    if len(snakes) > 1:
        if key == 'up' and snake2.direction != (0, 1):
            snake2.next_direction = (0, -1)
        elif key == 'down' and snake2.direction != (0, -1):
            snake2.next_direction = (0, 1)
        elif key == 'left' and snake2.direction != (1, 0):
            snake2.next_direction = (-1, 0)
        elif key == 'right' and snake2.direction != (-1, 0):
            snake2.next_direction = (1, 0)
```

**Механизм управления:**
1. **Разделение клавиш**: 
   - Игрок 1: WASD (w-вверх, s-вниз, a-влево, d-вправо)
   - Игрок 2: Стрелки (↑↓←→)

2. **Защита от разворота**: Проверка `snake.direction != противоположное` предотвращает мгновенный разворот на 180°, что привело бы к столкновению с собой

3. **Асинхронное управление**: Оба игрока могут нажимать клавиши одновременно, направления сохраняются в `next_direction` и применяются в следующем игровом цикле

### 1.3 Игровой цикл

```python
def game_loop():
    # Двигаем змейки
    for snake in snakes:
        snake.move()  # Применяет next_direction
        
        # Проверка столкновений и еды
        if check_collision(snake):
            collision_occurred = True
            break
        
        if snake.body[0] == food:
            snake.grow()
            place_food()
            # Обновление счета для соответствующего игрока
```

**Особенности:**
- Обе змейки обрабатываются в едином цикле
- Каждая змейка независимо проверяется на столкновения и поедание еды
- Счет обновляется индивидуально для каждого игрока

### 1.4 Отображение счета

В режиме мультиплеера отображаются оба счетчика:
- "Счёт игрока 1" - для `snake1`
- "Счёт игрока 2" - для `snake2`

---

## 2. Реализация игры с компьютером (режим "Против компьютера")

### 2.1 Инициализация

```python
else:  # mode == "computer"
    snake1 = Snake((5, rows // 2), (1, 0), "#FF6B9D")
    snake2 = Snake((cols - 6, rows // 2), (-1, 0), "#4ECDC4")  # Бот
    snakes = [snake1, snake2]
    # Скрываем счет второго игрока
    score_label2.grid_remove()
    score_value2.grid_remove()
```

**Отличия от мультиплеера:**
- Создаются те же две змейки, но `snake2` управляется ботом
- Счет второго игрока скрыт через `grid_remove()` (не удаляется, просто невидим)

### 2.2 Алгоритм поиска пути (A*)

```python
def find_path_to_food(snake, food, obstacles, cols, rows):
    """Находит оптимальный путь к еде используя алгоритм A*"""
    start = snake.body[0]
    goal = food
    
    def heuristic(pos):
        """Манхэттенское расстояние"""
        return abs(pos[0] - goal[0]) + abs(pos[1] - goal[1])
```

**Алгоритм A*:**
1. **Эвристика**: Манхэттенское расстояние (L1-норма) - сумма разностей по X и Y
2. **Приоритетная очередь**: Использует `heapq` для эффективного выбора следующей клетки
3. **Оценка пути**: `f_score = g_score + heuristic`, где:
   - `g_score` - реальное расстояние от старта
   - `heuristic` - оценка расстояния до цели
4. **Восстановление пути**: После достижения цели путь восстанавливается через `came_from`

**Учет препятствий:**
```python
obstacle_set = set()
for obstacle in obstacles:
    obstacle_set.update(obstacle)  # Все тела змеек
```

### 2.3 Логика управления ботом

```python
def get_bot_direction(snake, food, all_snakes, cols, rows):
    # Приоритет 1: A* алгоритм
    next_pos = find_path_to_food(snake, food, obstacles, cols, rows)
    if next_pos:
        # Вычисляем направление из позиции
        dx = next_pos[0] - head_x
        dy = next_pos[1] - head_y
        return (dx, dy)
    
    # Приоритет 2: Жадный алгоритм (fallback)
    # Выбирает направление, минимизирующее расстояние до еды
```

**Двухуровневая стратегия:**

**Уровень 1 - A* (оптимальный путь):**
- Находит кратчайший путь к еде
- Учитывает все препятствия
- Гарантирует достижение цели, если путь существует

**Уровень 2 - Жадный алгоритм (резервный):**
- Используется, если A* не нашел путь (загнан в угол)
- Перебирает 4 направления (вверх, вниз, влево, вправо)
- Исключает:
  - Разворот на 180° (проверка противоположного направления)
  - Выход за границы поля
  - Столкновение с препятствиями
- Выбирает направление с минимальным Манхэттенским расстоянием до еды

### 2.4 Интеграция бота в игровой цикл

```python
def game_loop():
    # Управление ботом (в режиме против компьютера)
    if mode == "computer" and len(snakes) > 1:
        bot_direction = get_bot_direction(snake2, food, snakes, cols, rows)
        if bot_direction:
            snake2.next_direction = bot_direction
    
    # Двигаем змейки (включая бота)
    for snake in snakes:
        snake.move()
```

**Последовательность действий:**
1. **Перед каждым ходом**: Бот вычисляет оптимальное направление
2. **Установка направления**: `snake2.next_direction` обновляется
3. **Движение**: Бот движется так же, как и игрок, через `snake.move()`
4. **Проверки**: Бот проходит те же проверки столкновений и еды

### 2.5 Особенности поведения бота

**Преимущества A*:**
- Находит оптимальный путь
- Избегает тупиков
- Эффективно обходит препятствия

**Ограничения:**
- Не предсказывает будущие движения игрока
- Не использует стратегию блокировки
- Может попасть в ловушку, если путь заблокирован

**Жадный алгоритм как защита:**
- Активируется при отсутствии пути A*
- Выбирает безопасное направление
- Минимизирует риск столкновения

---

## 3. Общие механизмы для обоих режимов

### 3.1 Единая обработка змеек

```python
snakes = [snake1, snake2]  # Одинаково для обоих режимов

for snake in snakes:
    snake.move()
    if check_collision(snake):
        # Одинаковая логика для всех
```

### 3.2 Проверка столкновений

```python
def check_collision(snake):
    # Столкновение со стенами
    if head_x < 0 or head_x >= cols or head_y < 0 or head_y >= rows:
        return True
    
    # Столкновение с собой
    if snake.body[0] in snake.body[1:]:
        return True
    
    # Столкновение с другой змейкой
    for other_snake in snakes:
        if other_snake != snake and snake.body[0] in other_snake.body:
            return True
```

**Универсальность:** Одинаковая логика работает для игрока и бота

### 3.3 Автоматический перезапуск

```python
def reset_game():
    # Сброс обеих змеек в начальное положение
    snake1.body = [(5, rows // 2)]
    snake2.body = [(cols - 6, rows // 2)]
    # Сброс счетов, размещение новой еды
```

**Единый механизм:** При столкновении любой змейки игра перезапускается одинаково

---

## 4. Ключевые отличия режимов

| Аспект | Мультиплеер | Против компьютера |
|--------|-------------|-------------------|
| Управление snake1 | WASD (игрок) | WASD (игрок) |
| Управление snake2 | Стрелки (игрок) | Автоматически (бот) |
| Отображение счета | Оба счетчика | Только счет игрока |
| Логика snake2 | Ручное управление | `get_bot_direction()` |
| Вычисление направления | По нажатию клавиш | Каждый игровой цикл |

---

## 5. Технические детали

### 5.1 Производительность A*

- **Сложность**: O(b^d), где b - branching factor (4 направления), d - глубина пути
- **Оптимизация**: Использование `set` для O(1) проверки препятствий
- **Память**: Хранение `came_from`, `g_score`, `f_score` для каждой посещенной клетки

### 5.2 Синхронизация

- **Игровой цикл**: Единый `game_loop()` для всех змеек
- **Частота обновления**: Зависит от настроек скорости (100-200 мс)
- **Атомарность**: Все змейки двигаются в одном кадре

### 5.3 Расширяемость

Архитектура позволяет легко добавить:
- Больше игроков (расширить список `snakes`)
- Разные алгоритмы для бота (заменить `get_bot_direction`)
- Разные режимы игры (добавить новые значения `mode`)

